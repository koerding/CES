<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2-Nest Economic Model with Endogenous Labor Allocation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.2.1/chartjs-plugin-annotation.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2em;
            font-weight: 300;
        }

        .subtitle {
            text-align: center;
            color: #5a6c7d;
            margin-bottom: 30px;
            font-size: 1.1em;
            font-weight: 400;
            font-style: italic;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 30px;
            align-items: start;
        }
        
        .controls {
            background: #f8f9fa;
            border-radius: 15px;
            border: 1px solid #e9ecef;
            height: fit-content;
        }
        
        .ces-diagram {
            width: 100%;
            height: 300px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
            border-radius: 15px;
            border: 2px solid #d4d9ff;
        }
        
        .diagram-section {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .diagram-section:hover {
            transform: scale(1.05) translateY(-2px);
            filter: brightness(1.15) drop-shadow(0 4px 12px rgba(0, 0, 0, 0.2));
        }
        
        .diagram-section:active {
            transform: scale(1.02) translateY(0px);
            transition: all 0.1s ease;
        }
        
        .diagram-section.active {
            filter: brightness(1.2) drop-shadow(0 0 12px rgba(102, 126, 234, 0.6));
            transform: scale(1.03);
        }
        
        .section-text {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            fill: white;
            font-size: 14px;
        }
        
        .equation-text {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 400;
            text-anchor: middle;
            dominant-baseline: central;
            fill: white;
            font-size: 11px;
        }
        
        .input-label {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: central;
            fill: #495057;
            font-size: 10px;
        }
        
        .flow-arrow {
            stroke: #495057;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .labor-hub {
            cursor: default;
        }

        .labor-label {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 500;
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: central;
            fill: #495057;
        }

        .labor-arrow {
            stroke: #6c757d;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 3,2;
            marker-end: url(#arrowhead);
        }

        .allocation-label {
            font-family: 'Segoe UI', sans-serif;
            font-weight: 500;
            font-size: 11px;
            text-anchor: middle;
            dominant-baseline: central;
            fill: #6c757d;
        }
        
        .parameter-preview {
            font-family: 'Segoe UI', sans-serif;
            font-size: 9px;
            fill: rgba(255, 255, 255, 0.8);
            text-anchor: middle;
        }
        
        .tab-content {
            padding: 20px;
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content.physical-tab {
            border: 3px solid #4285f4;
            box-shadow: 0 0 10px rgba(66, 133, 244, 0.2);
        }
        
        .tab-content.intelligence-tab {
            border: 3px solid #34a853;
            box-shadow: 0 0 10px rgba(52, 168, 83, 0.2);
        }
        
        .tab-content.overall-tab {
            border: 3px solid #ea4335;
            box-shadow: 0 0 10px rgba(234, 67, 53, 0.2);
        }
        
        .tab-content.analysis-tab {
            border: 3px solid #fbbc04;
            box-shadow: 0 0 10px rgba(251, 188, 4, 0.2);
        }
        
        .charts {
            display: grid;
            gap: 25px;
        }
        
        .chart-container {
            background: white;
            padding: 10px 20px 20px 20px;
            border-radius: 0 0 15px 15px;
            position: relative;
            height: 260px;
        }
        
        .chart-wrapper-with-header {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
        }
        
        .parameter-group {
            margin-bottom: 18px;
        }
        
        .parameter-label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 6px;
            font-size: 0.85em;
        }
        
        .parameter-description {
            font-size: 0.7em;
            color: #6c757d;
            margin-bottom: 6px;
            line-height: 1.2;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        .slider-value {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
            color: #495057;
            font-size: 0.8em;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle.active {
            background: #667eea;
        }
        
        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle.active .toggle-knob {
            transform: translateX(26px);
        }
        
        .status {
            text-align: center;
            padding: 10px;
            margin-top: 15px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.85em;
        }
        
        .status.success {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .status.error {
            background: #fed7d7;
            color: #c53030;
        }
        
        .equation-display {
            margin-top: 20px;
            padding: 15px;
            background: #f0f4ff;
            border-radius: 10px;
            border: 1px solid #d4d9ff;
            text-align: center;
            font-size: 0.88em;
            overflow-x: auto;
        }
        
        .equation-chart-container {
            margin-top: 10px;
            padding: 15px;
            background: #f0f4ff;
            border-radius: 10px;
            border: 1px solid #d4d9ff;
            height: 400px;
            position: relative;
        }
        
        .chart-wrapper {
            position: relative;
            margin-bottom: 20px;
        }
        
        .chart-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px 5px 20px;
            background: white;
            border-radius: 15px 15px 0 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .chart-legend {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: #666;
        }
        
        .legend-color {
            width: 15px;
            height: 3px;
            border-radius: 1px;
        }
        
        .export-buttons {
            display: flex;
            gap: 5px;
        }
        
        .export-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            color: #333;
        }
        
        .export-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .button-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .reset-button, .toggle-explanations {
            flex: 1;
            padding: 12px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reset-button:hover {
            background: #e74c3c;
            color: white;
            border-color: #e74c3c;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.2);
        }
        
        .toggle-explanations:hover {
            background: #3498db;
            color: white;
            border-color: #3498db;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.2);
        }
        
        .toggle-explanations.explanations-off {
            background: #95a5a6;
            color: white;
            border-color: #95a5a6;
        }
        
        .toggle-explanations.explanations-off:hover {
            background: #7f8c8d;
            border-color: #7f8c8d;
        }
        
        .reset-button:active, .toggle-explanations:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.2);
        }
        
        .parameter-description.minimized {
            display: none;
        }
        
        .parameter-label.has-tooltip {
            cursor: help;
            border-bottom: 1px dotted #666;
            position: relative;
        }
        
        .parameter-label.has-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 24px;
            font-weight: normal;
            white-space: pre-wrap;
            max-width: 390px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            margin-bottom: 5px;
        }
        
        .parameter-label.has-tooltip:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 15px;
            border: 5px solid transparent;
            border-top-color: #333;
            z-index: 1001;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive 2‑Nest CES: Physical vs. Intelligence</h1>
        <div class="subtitle">Simulations for the manuscript "Intelligence Saturation" by Ioana Marinescu and Konrad Kording</div>

        <div class="main-content">
            <div class="controls">
                <div class="button-container">
                    <button class="reset-button" onclick="resetAllParameters()">Reset to Baseline</button>
                    <button class="toggle-explanations" onclick="toggleExplanations()" id="explanationsToggle">Toggle tool tips</button>
                </div>
                <svg class="ces-diagram" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                         refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#495057" />
                        </marker>
                    </defs>
                    
                    <!-- Physical Production Section -->
                    <g class="diagram-section" data-tab="0" onclick="switchTab(0)">
                        <rect x="20" y="20" width="120" height="60" rx="10" fill="#4285f4" stroke="#2c5aa0" stroke-width="2"/>
                        <text x="80" y="40" class="section-text">Physical</text>
                        <text x="80" y="55" class="section-text">Production</text>
                        <text x="80" y="70" class="equation-text">P = f(L<tspan baseline-shift="sub" font-size="8px">P</tspan>, K<tspan baseline-shift="sub" font-size="8px">P</tspan>)</text>
                    </g>
                    
                    <!-- Intelligence Production Section -->
                    <g class="diagram-section" data-tab="1" onclick="switchTab(1)">
                        <rect x="260" y="20" width="120" height="60" rx="10" fill="#34a853" stroke="#2d7a3e" stroke-width="2"/>
                        <text x="320" y="40" class="section-text">Intelligence</text>
                        <text x="320" y="55" class="section-text">Production</text>
                        <text x="320" y="70" class="equation-text">I = f(L<tspan baseline-shift="sub" font-size="8px">I</tspan>, K<tspan baseline-shift="sub" font-size="8px">I</tspan>)</text>
                    </g>
                    
                    <!-- Overall Production Section -->
                    <g class="diagram-section" data-tab="2" onclick="switchTab(2)">
                        <rect x="100" y="150" width="200" height="60" rx="10" fill="#ea4335" stroke="#c5221f" stroke-width="2"/>
                        <text x="200" y="175" class="section-text">Overall Production</text>
                        <text x="200" y="190" class="equation-text">Y = f(P, I)</text>
                    </g>
                    
                    <!-- Analysis Section -->
                    <g class="diagram-section" data-tab="3" onclick="switchTab(3)">
                        <rect x="130" y="230" width="140" height="40" rx="10" fill="#fbbc04" stroke="#f29900" stroke-width="2"/>
                        <text x="200" y="245" class="section-text">Analysis & Charts</text>
                        <text x="200" y="260" class="equation-text">Evolution & Saturation</text>
                    </g>
                    
                    <!-- Labor Allocation Hub -->
                    <g class="labor-hub">
                        <circle cx="200" cy="50" r="30" fill="#f8f9fa" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,3"/>
                        <text x="200" y="43" class="labor-label">Total</text>
                        <text x="200" y="57" class="labor-label">Labor (L)</text>
                    </g>
                    
                    <!-- Production Flow Arrows -->
                    <path class="flow-arrow" d="M 80 80 Q 150 110 190 150" />
                    <path class="flow-arrow" d="M 320 80 Q 250 110 210 150" />
                    <path class="flow-arrow" d="M 200 215 L 200 230" />
                    
                    <!-- Labor Allocation Arrows -->
                    <path class="labor-arrow" d="M 170 50 L 140 50" />
                    <path class="labor-arrow" d="M 230 50 L 260 50" />
                    
                    <!-- Labor Split Labels -->
                    <text x="155" y="35" class="allocation-label">L<tspan baseline-shift="sub" font-size="9px">P</tspan></text>
                    <text x="245" y="35" class="allocation-label">L<tspan baseline-shift="sub" font-size="9px">I</tspan></text>
                </svg>
                
                <div class="tab-content active physical-tab">
                    <div class="parameter-group">
                        <label class="parameter-label">Physical Capital (K<sub>P</sub>)</label>
                        <div class="parameter-description">Physical capital ($K_P$) represents traditional capital goods like machines, buildings, and equipment used in physical production. This is distinct from AI/intelligence capital. Higher $K_P$ means more physical infrastructure per worker - think factories with more machines, construction with better equipment, or restaurants with more kitchen tools. $K_P=1.38$ is calibrated to match the 2023 US economy's capital-to-labor ratio of about 4.6.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="K" min="0.5" max="3.0" step="0.1" value="1.38">
                            <span class="slider-value" id="K_value">1.38</span>
                        </div>
                    </div>
                    
                    <div class="parameter-group">
                        <label class="parameter-label">P-nest Substitution (ρ<sub>P</sub>)</label>
                        <div class="parameter-description">The substitution parameter ($\rho_P$) controls how easily physical capital can replace human labor in physical tasks. When $\rho_P=1$, robots can perfectly replace workers (perfect substitutes). When $\rho_P=0$, you get the standard Cobb-Douglas case (intermediate substitutability). When $\rho_P \to -\infty$, capital and labor are perfect complements - you need both in fixed proportions, like a driver and a truck. Our baseline $\rho_P=-0.67$ gives an elasticity of substitution $\sigma=0.6$, matching empirical estimates from US manufacturing where machines and workers are somewhat complementary but not perfectly so. Lower $\rho_P$ means it's harder for robots to replace physical workers.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="rho_P" min="-2.0" max="0.99" step="0.05" value="-0.67">
                            <span class="slider-value" id="rho_P_value">-0.67</span>
                            <span class="elasticity-display" id="sigma_P_display" style="margin-left: 10px; font-size: 0.9em; color: #666;">σ = 0.6</span>
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label class="parameter-label">Capital Weight in P-nest (α<sub>P</sub>)</label>
                        <div class="parameter-description">The capital weight $\alpha_P$ represents the distribution parameter in the physical CES production function.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="alpha_P" min="0.1" max="0.9" step="0.05" value="0.7">
                            <span class="slider-value" id="alpha_P_value">0.7</span>
                        </div>
                    </div>
                    
                    <div class="parameter-group">
                        <label class="parameter-label">P-nest Aggregation Method</label>
                        <div class="parameter-description">Choose how to aggregate capital and labor in physical production. CES: Standard production function. CES with scale (DS-weights): Adds θ and DS-style weights α^(1-ρ); no love-of-variety micro-foundation implied.</div>
                        <div class="toggle-container">
                            <span>CES</span>
                            <div class="toggle" id="p_agg_toggle" onclick="togglePAggregation()">
                                <div class="toggle-knob"></div>
                            </div>
                            <span>CES with scale</span>
                        </div>
                    </div>
                    
                    <div class="parameter-group p-ds-params" style="display: none;">
                        <label class="parameter-label">P-nest Scaling (θ<sub>P</sub>)</label>
                        <div class="parameter-description">Returns to scale ($\theta_P$) captures whether physical production exhibits economies or diseconomies of scale. $\theta_P=1$ means constant returns - doubling all inputs doubles output (standard assumption). $\theta_P<1$ means decreasing returns - doubling inputs less than doubles output, perhaps due to coordination costs, limited space, or management complexity. $\theta_P>1$ would mean increasing returns from economies of scale. This only appears with DS aggregation and helps model realistic production constraints in the physical world. Lower $\theta_P$ means intelligence saturation happens faster.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="theta_P" min="0.1" max="1.0" step="0.02" value="1.0">
                            <span class="slider-value" id="theta_P_value">1.0</span>
                        </div>
                    </div>
                    
                    <div class="equation-display" id="physical-equation">
                        $$P = \left[\alpha_P K_P^{\rho_P} + (1-\alpha_P) L_P^{\rho_P}\right]^{1/\rho_P}$$
                    </div>
                    
                    <div class="equation-chart-container">
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('physicalChart', 'physical_production')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('physicalChart', 'physical_production')">CSV</button>
                        </div>
                        <canvas id="physicalChart"></canvas>
                    </div>
                </div>
                
                <div class="tab-content intelligence-tab">
                    <div class="parameter-group">
                        <label class="parameter-label">AI Capital (K<sub>I</sub>)</label>
                        <div class="parameter-description">AI capital ($K_I$) represents the effective computational capacity available for intelligence tasks - think of it as the total "brain power" from all AI systems combined. This includes hardware (GPUs, servers), software efficiency, and algorithmic improvements. $K_I=9$ represents an "abundant AI" scenario where there's 9 times more AI capital than human labor. Higher $K_I$ means more AI available to automate tasks.</div>
                        <div id="ai-capital-note" class="parameter-note" style="display: none; margin-top: 5px; font-style: italic; color: #666;">This gets changed during simulation on right.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="AI" min="0" max="5" step="0.1" value="0.95">
                            <span class="slider-value" id="AI_value">9.0</span>
                        </div>
                    </div>
                    
                    <div class="parameter-group">
                        <label class="parameter-label">I-nest Substitution (ρ<sub>I</sub>)</label>
                        <div class="parameter-description">Intelligence substitution parameter ($\rho_I$) controls how easily AI can replace humans in cognitive tasks and how different intelligence tasks substitute for each other. When $\rho_I=1$, AI can perfectly replace humans in intelligence tasks (perfect substitutes). When $\rho_I=0$, you get the standard Cobb-Douglas case (intermediate substitutability). Low $\rho_I$ means AI and humans are more complementary - they work better together. Our baseline $\rho_I=0.55$ gives an elasticity of substitution $\sigma=2.2$, reflecting high substitutability between intelligence tasks (consistent with how programming, writing, analysis, and other cognitive tasks can often substitute for each other).</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="rho_I" min="-2.0" max="0.99" step="0.05" value="0.55">
                            <span class="slider-value" id="rho_I_value">0.55</span>
                            <span class="elasticity-display" id="sigma_I_display" style="margin-left: 10px; font-size: 0.9em; color: #666;">σ = 2.2</span>
                        </div>
                    </div>
                    
                    
                    <div class="parameter-group i-ds-params">
                        <label class="parameter-label">I-nest Scaling (θ<sub>I</sub>)</label>
                        <div class="parameter-description">Intelligence scaling parameter ($\theta_I$) captures diminishing returns to AI and labor in the production of intelligence. $\theta_I=1$ means constant returns - doubling both AI and human labor doubles intelligence. $\theta_I<1$ means decreasing returns, so that doubling both inputs increases intelligence less than proportionally. Our baseline $\theta_I=0.94$ reflects empirical estimates from professional services sectors. Lower $\theta_I$ implies stronger diminishing returns to AI investment in terms of producing intelligence.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="theta_I" min="0.1" max="1.0" step="0.02" value="0.94">
                            <span class="slider-value" id="theta_I_value">0.94</span>
                        </div>
                    </div>
                    
                    <div class="equation-display" id="intelligence-equation">
                        $$I = \left[\alpha_I^{1-\rho_I} K_I^{\rho_I} + (1-\alpha_I)^{1-\rho_I} L_I^{\rho_I}\right]^{\theta/\rho_I}$$
                    </div>
                    
                    <div class="equation-chart-container">
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('intelligenceChart', 'intelligence_production')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('intelligenceChart', 'intelligence_production')">CSV</button>
                        </div>
                        <canvas id="intelligenceChart"></canvas>
                    </div>
                </div>
                
                <div class="tab-content overall-tab">
                    
                    <div class="parameter-group">
                        <label class="parameter-label">Total Labor (L)</label>
                        <div class="parameter-description">Total labor supply ($L$) represents the size of the workforce, normalized to $L=1$ as baseline. Labor endogenously reallocates between physical and intelligence tasks to equalize marginal productivity (wages) across physical and intelligence sectors. As AI automates more intelligence tasks, workers optimally shift toward physical production. The model solves for the optimal allocation $\beta^*$ that balances wages between sectors. Increasing $L$ leads to more labor relative to capital, which makes workers less productive when they reallocate to the capital-limited physical sector.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="L" min="0.5" max="2.0" step="0.1" value="1.0">
                            <span class="slider-value" id="L_value">1.0</span>
                        </div>
                    </div>

                    <div class="parameter-group ces-params">
                        <label class="parameter-label">Top-level Substitution (ρ)</label>
                        <div class="parameter-description">The macro substitution parameter ($\rho$) is the most important parameter in the model - it determines whether we get intelligence saturation or explosive AI growth. When $\rho<0$, physical and intelligence inputs are complements, leading to intelligence saturation where additional AI yields diminishing returns. When $\rho>0$, they're substitutes, allowing unbounded growth as the growth effects of AI are not dragged down by physical production. Our baseline $\rho=-0.67$ ($\sigma=0.6$ elasticity) treats them as complements, reflecting that you can't build cars with pure intelligence - you need both smart control systems AND physical materials/assembly. This parameter determines whether we get the economists' 'bounded growth' view or the AI experts' 'singularity' scenario.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="rho" min="-2.0" max="0.99" step="0.05" value="-0.67">
                            <span class="slider-value" id="rho_value">-0.67</span>
                            <span class="elasticity-display" id="sigma_display" style="margin-left: 10px; font-size: 0.9em; color: #666;">σ = 0.6</span>
                        </div>
                    </div>

                    <div class="parameter-group ces-params">
                        <label class="parameter-label">P-weight in Top CES (τ)</label>
                        <div class="parameter-description">The physical weight $\tau$ represents the distribution parameter in the overall CES production function.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="tau" min="0.1" max="0.9" step="0.01" value="0.20">
                            <span class="slider-value" id="tau_value">0.20</span>
                        </div>
                    </div>
                    
                    
                    <div class="equation-display" id="overall-equation">
                        $$Y = \left[\tau P^{\rho} + (1-\tau) I^{\rho}\right]^{1/\rho}$$
                    </div>
                    
                    <div class="equation-chart-container">
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('functionChart', 'production_function')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('functionChart', 'production_function')">CSV</button>
                        </div>
                        <canvas id="functionChart"></canvas>
                    </div>
                </div>
                
                <div class="tab-content analysis-tab">
                    <div class="parameter-group">
                        <label class="parameter-label">AI Evolution Mode</label>
                        <div class="parameter-description">Choose the AI development scenario. 'Fixed AI' holds AI capital and automation levels constant - useful for understanding static equilibrium effects of different automation levels. 'Exponential AI' simulates realistic AI development where both AI capital ($K_I$) grows exponentially (following observed cost reductions) and automation ($\alpha_I$) progresses over time as AI capabilities expand. Exponential mode captures the dynamic transition that we're likely experiencing now, while Fixed mode helps isolate the effects of different automation equilibria.</div>
                        <div class="toggle-container">
                            <span>Fixed AI</span>
                            <div class="toggle" id="ai_mode_toggle" onclick="toggleAIMode()">
                                <div class="toggle-knob"></div>
                            </div>
                            <span>Exponential AI</span>
                        </div>
                    </div>
                    
                    <div class="parameter-group" id="scenario-description">
                        <div class="parameter-description" id="scenario-text" style="font-weight: 600; color: #2c3e50; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                            We increase the importance of intelligence in overall production.
                        </div>
                    </div>
                    
                    <div class="parameter-group exponential-params" style="display: none;">
                        <label class="parameter-label">Transition Time (years)</label>
                        <div class="parameter-description">Transition time sets how quickly automation progresses from $\alpha_I=0$ (no automation) to $\alpha_I=1$ (full automation of intelligence tasks). Shorter transitions (2-5 years) reflect rapid AI development scenarios like the current LLM revolution. Longer transitions (20-50 years) reflect more gradual technological adoption considering institutional inertia, regulation, and training time.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="transition_time" min="2" max="100" step="1" value="10">
                            <span class="slider-value" id="transition_time_value">10</span>
                        </div>
                    </div>
                    
                    <div class="parameter-group exponential-params" style="display: none;">
                        <label class="parameter-label">AI Capital Doubling Time (months)</label>
                        <div class="parameter-description">This parameter controls how long it takes in months to double the amount of AI capital, $K_I$. Faster doubling (1-6 months) reflects the breakneck pace of AI development around 2025. Slower doubling (12-24 months) reflects more mature technology phases or potential slowdowns due to e.g. physical limits or economic constraints.</div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="doubling_time" min="1" max="24" step="1" value="3">
                            <span class="slider-value" id="doubling_time_value">3</span>
                        </div>
                    </div>
                </div>
                
                <div class="status" id="status"></div>
            </div>
            
            <div class="charts">
                <div class="chart-wrapper-with-header">
                    <div class="chart-header">
                        <div class="chart-title">Wage vs α<sub>I</sub></div>
                        <div class="chart-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e74c3c;"></div>
                                <span>Wage</span>
                            </div>
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('wageChart', 'wage')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('wageChart', 'wage')">CSV</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="wageChart"></canvas>
                    </div>
                </div>
                <div class="chart-wrapper-with-header">
                    <div class="chart-header">
                        <div class="chart-title">Total Output vs α<sub>I</sub></div>
                        <div class="chart-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #27ae60;"></div>
                                <span>Total Output Y</span>
                            </div>
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('outputChart', 'output')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('outputChart', 'output')">CSV</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="outputChart"></canvas>
                    </div>
                </div>
                <div class="chart-wrapper-with-header">
                    <div class="chart-header">
                        <div class="chart-title">P and I Components vs α<sub>I</sub></div>
                        <div class="chart-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #9b59b6;"></div>
                                <span>P-nest Output</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #f39c12;"></div>
                                <span>I-nest Output</span>
                            </div>
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('componentsChart', 'components')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('componentsChart', 'components')">CSV</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="componentsChart"></canvas>
                    </div>
                </div>
                <div class="chart-wrapper-with-header">
                    <div class="chart-header">
                        <div class="chart-title">Optimal Labor Allocation vs α<sub>I</sub></div>
                        <div class="chart-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #3498db;"></div>
                                <span>β* (Optimal P-labor share)</span>
                            </div>
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('allocationChart', 'allocation')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('allocationChart', 'allocation')">CSV</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="allocationChart"></canvas>
                    </div>
                </div>
                <div class="chart-wrapper-with-header">
                    <div class="chart-header">
                        <div class="chart-title">Intelligence Saturation</div>
                        <div class="chart-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #9b59b6;"></div>
                                <span>Intelligence Saturation</span>
                            </div>
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('saturationChart', 'saturation')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('saturationChart', 'saturation')">CSV</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="saturationChart"></canvas>
                    </div>
                </div>
                <div class="chart-wrapper-with-header" id="secretChart" style="display: none;">
                    <div class="chart-header">
                        <div class="chart-title">Productivity Analysis</div>
                        <div class="chart-legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e74c3c;"></div>
                                <span>Productivity</span>
                            </div>
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChartPNG('productivityChart', 'productivity')">PNG</button>
                            <button class="export-btn" onclick="exportChartCSV('productivityChart', 'productivity')">CSV</button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="productivityChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        const ALPHA_EPS = 1e-6;   // use right-limit at 0 and left-limit at 1
        let currentAgg = 'CES';
        let currentAIMode = 'Fixed';
        let currentPAgg = 'CES'; // Physical nest aggregation method (default)
        let currentIAgg = 'DS'; // Intelligence nest aggregation method (default to maintain existing behavior)
        let currentTab = 0; // Current active tab (0=Physical, 1=Intelligence, 2=Overall, 3=Analysis)
        
        // Tab switching functionality
        function switchTab(tabIndex) {
            // Update global state
            currentTab = tabIndex;
            
            // Update SVG diagram visual state
            const sections = document.querySelectorAll('.diagram-section');
            sections.forEach((section, index) => {
                if (index === tabIndex) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            });
            
            // Update tab content visibility
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach((content, index) => {
                if (index === tabIndex) {
                    content.classList.add('active');
                    content.style.display = 'block';
                } else {
                    content.classList.remove('active');
                    content.style.display = 'none';
                }
            });
            
            // Update charts when switching tabs
            setTimeout(() => {
                updateCharts();
            }, 100);
        }
        
        // Mathematical functions
        // Generic CES production function
        function computeCES(input1, input2, alpha, rho) {
            if (Math.abs(rho) < 1e-10) {
                // Cobb-Douglas case: input1^α * input2^(1-α)
                return Math.pow(input1, alpha) * Math.pow(input2, 1 - alpha);
            }
            const inside = alpha * Math.pow(input1, rho) + (1 - alpha) * Math.pow(input2, rho);
            return Math.pow(inside, 1 / rho);
        }

        // Generic DS (Dixit-Stiglitz) production function
        function computeDS(input1, input2, alpha, rho, theta) {
            // Safety bounds to prevent singularities
            const safe_alpha = Math.min(Math.max(alpha, 1e-6), 1 - 1e-6);
            const safe_input1 = Math.max(input1, 1e-10);
            const safe_input2 = Math.max(input2, 1e-10);
            
            if (Math.abs(rho) < 1e-8) {
                // Lazy continuity approach: average of DS(+0.01) and DS(-0.01)
                const eps = 0.01;
                const pos_inside = Math.pow(safe_alpha, 1 - eps) * Math.pow(safe_input1, eps) + Math.pow(1 - safe_alpha, 1 - eps) * Math.pow(safe_input2, eps);
                const pos_result = Math.pow(pos_inside, theta / eps);
                const neg_inside = Math.pow(safe_alpha, 1 + eps) * Math.pow(safe_input1, -eps) + Math.pow(1 - safe_alpha, 1 + eps) * Math.pow(safe_input2, -eps);
                const neg_result = Math.pow(neg_inside, theta / (-eps));
                return (pos_result + neg_result) / 2;
            }
            
            // For negative rho and alpha near 1, use additional safety measures
            if (rho < 0 && safe_alpha > 0.99) {
                // Gradually transition to Cobb-Douglas near the boundary
                const transition_alpha = 0.99;
                const weight = Math.max(0, Math.min(1, (safe_alpha - transition_alpha) / (1 - transition_alpha)));
                
                // Cobb-Douglas approximation
                const cd_result = Math.pow(safe_input1, safe_alpha) * Math.pow(safe_input2, 1 - safe_alpha);
                const cd_scaled = Math.pow(cd_result, theta);
                
                // DS computation with clamped alpha
                const ds_alpha = Math.min(safe_alpha, transition_alpha);
                const inside = Math.pow(ds_alpha, 1 - rho) * Math.pow(safe_input1, rho) + Math.pow(1 - ds_alpha, 1 - rho) * Math.pow(safe_input2, rho);
                const ds_result = Math.pow(inside, theta / rho);
                
                // Interpolate between DS and Cobb-Douglas
                return (1 - weight) * ds_result + weight * cd_scaled;
            }
            
            const inside = Math.pow(safe_alpha, 1 - rho) * Math.pow(safe_input1, rho) + Math.pow(1 - safe_alpha, 1 - rho) * Math.pow(safe_input2, rho);
            return Math.pow(inside, theta / rho);
        }

        // Generic CES derivative with respect to input2
        function dCES_dinput2(input1, input2, alpha, rho) {
            if (Math.abs(rho) < 1e-10) {
                // Cobb-Douglas case: d/dinput2[input1^α * input2^(1-α)] = (1-α) * input1^α * input2^(-α)
                return (1 - alpha) * Math.pow(input1, alpha) * Math.pow(input2, -alpha);
            }
            const inside = alpha * Math.pow(input1, rho) + (1 - alpha) * Math.pow(input2, rho);
            return (1 - alpha) * Math.pow(input2, rho - 1) * Math.pow(inside, (1 / rho) - 1);
        }

        // Generic DS derivative with respect to input2
        function dDS_dinput2(input1, input2, alpha, rho, theta) {
            // Safety bounds to prevent singularities
            const safe_alpha = Math.min(Math.max(alpha, 1e-6), 1 - 1e-6);
            const safe_input1 = Math.max(input1, 1e-10);
            const safe_input2 = Math.max(input2, 1e-10);
            
            if (Math.abs(rho) < 1e-8) {
                // Lazy continuity approach: average of derivatives at +0.01 and -0.01
                const eps = 0.01;
                const pos_inside = Math.pow(safe_alpha, 1 - eps) * Math.pow(safe_input1, eps) + Math.pow(1 - safe_alpha, 1 - eps) * Math.pow(safe_input2, eps);
                const pos_deriv = theta * Math.pow(1 - safe_alpha, 1 - eps) * Math.pow(safe_input2, eps - 1) * Math.pow(pos_inside, (theta / eps) - 1);
                const neg_inside = Math.pow(safe_alpha, 1 + eps) * Math.pow(safe_input1, -eps) + Math.pow(1 - safe_alpha, 1 + eps) * Math.pow(safe_input2, -eps);
                const neg_deriv = theta * Math.pow(1 - safe_alpha, 1 + eps) * Math.pow(safe_input2, -eps - 1) * Math.pow(neg_inside, (theta / (-eps)) - 1);
                return (pos_deriv + neg_deriv) / 2;
            }
            
            // For negative rho and alpha near 1, use additional safety measures
            if (rho < 0 && safe_alpha > 0.99) {
                // Use finite difference approximation for the derivative near the boundary
                const h = 1e-6;
                const f_plus = computeDS(safe_input1, safe_input2 + h, safe_alpha, rho, theta);
                const f_minus = computeDS(safe_input1, safe_input2 - h, safe_alpha, rho, theta);
                return (f_plus - f_minus) / (2 * h);
            }
            
            const inside = Math.pow(safe_alpha, 1 - rho) * Math.pow(safe_input1, rho) + Math.pow(1 - safe_alpha, 1 - rho) * Math.pow(safe_input2, rho);
            return theta * Math.pow(1 - safe_alpha, 1 - rho) * Math.pow(safe_input2, rho - 1) * Math.pow(inside, (theta / rho) - 1);
        }

        function computeP(LP, K, alpha_P, rho_P, theta_P = 1.0) {
            if (currentPAgg === 'DS') {
                return computeDS(K, LP, alpha_P, rho_P, theta_P);
            } else {
                return computeCES(K, LP, alpha_P, rho_P);
            }
        }
        
        function dP_dLP(LP, K, alpha_P, rho_P, theta_P = 1.0) {
            if (currentPAgg === 'DS') {
                return dDS_dinput2(K, LP, alpha_P, rho_P, theta_P);
            } else {
                return dCES_dinput2(K, LP, alpha_P, rho_P);
            }
        }
        
function computeI(LI, alpha_I, AI, rho_I, theta_I) {
    // Intelligence nest always uses DS (CES with scale)
    return computeDS(AI, LI, alpha_I, rho_I, theta_I);
}

function dI_dLI(LI, alpha_I, AI, rho_I, theta_I) {
    // Intelligence nest always uses DS (CES with scale)
    return dDS_dinput2(AI, LI, alpha_I, rho_I, theta_I);
}
        // PSI function removed - overall aggregation always uses CES
        
        function dY_dP_psi(P, I, params) {
            const x = P != 0 ? I / P : 0.0;
            const eta = params.eta;
            const a = params.a_param;
            const denom = a + Math.pow(x, eta);
            const sig = denom != 0 ? Math.pow(x, eta) / denom : 0.0;
            const dsig = denom != 0 ? (a * eta * Math.pow(x, eta - 1) / Math.pow(denom, 2)) : 0.0;
            return sig - x * dsig;
        }
        
        function dY_dI_psi(P, I, params) {
            const x = P != 0 ? I / P : 0.0;
            const eta = params.eta;
            const a = params.a_param;
            const denom = a + Math.pow(x, eta);
            return denom != 0 ? (a * eta * Math.pow(x, eta - 1) / Math.pow(denom, 2)) : 0.0;
        }
        
        function computeY(P, I, params) {
            // Overall aggregation always uses CES
            const rho = params.rho;
            const tau = params.tau;

            if (Math.abs(rho) < 1e-10) {
                // Cobb-Douglas case: Y = P^τ * I^(1-τ)
                return Math.pow(P, tau) * Math.pow(I, 1 - tau);
            }

            const inside = tau * Math.pow(P, rho) + (1 - tau) * Math.pow(I, rho);
            return Math.pow(inside, 1 / rho);
        }
        
        function dY_dP(P, I, params) {
            if (params.agg === 'CES') {
                const rho = params.rho;
                const tau = params.tau;
                
                if (Math.abs(rho) < 1e-10) {
                    // Cobb-Douglas case: dY/dP = τ * P^(τ-1) * I^(1-τ)
                    return tau * Math.pow(P, tau - 1) * Math.pow(I, 1 - tau);
                }
                
                const inside = tau * Math.pow(P, rho) + (1 - tau) * Math.pow(I, rho);
                return tau * Math.pow(P, rho - 1) * Math.pow(inside, (1 / rho) - 1);
            } else {
                return dY_dP_psi(P, I, params);
            }
        }
        
        function dY_dI(P, I, params) {
            if (params.agg === 'CES') {
                const rho = params.rho;
                const tau = params.tau;
                
                if (Math.abs(rho) < 1e-10) {
                    // Cobb-Douglas case: dY/dI = (1-τ) * P^τ * I^(-τ)
                    return (1 - tau) * Math.pow(P, tau) * Math.pow(I, -tau);
                }
                
                const inside = tau * Math.pow(P, rho) + (1 - tau) * Math.pow(I, rho);
                return (1 - tau) * Math.pow(I, rho - 1) * Math.pow(inside, (1 / rho) - 1);
            } else {
                return dY_dI_psi(P, I, params);
            }
        }
        
        function MP_P(alpha_P, alpha_I, params) {
            const L = params.L;
            const LP = alpha_P * L;
            const LI = (1 - alpha_P) * L;
            const P = computeP(LP, params.K, params.alpha_P, params.rho_P, params.theta_P);
            const I = computeI(LI, alpha_I, params.AI, params.rho_I, params.theta_I);
            return dY_dP(P, I, params) * dP_dLP(LP, params.K, params.alpha_P, params.rho_P, params.theta_P);
        }
        
        function MP_I(alpha_P, alpha_I, params) {
            const L = params.L;
            const LP = alpha_P * L;
            const LI = (1 - alpha_P) * L;
            const P = computeP(LP, params.K, params.alpha_P, params.rho_P, params.theta_P);
            const I = computeI(LI, alpha_I, params.AI, params.rho_I, params.theta_I);
            return dY_dI(P, I, params) * dI_dLI(LI, alpha_I, params.AI, params.rho_I, params.theta_I);
        }
        
        // Brent's method for root finding
        function brentq(func, a, b, tolerance = 1e-10, maxIter = 100) {
            let fa = func(a);
            let fb = func(b);
            
            if (fa * fb > 0) {
                // Return the closer boundary if no bracket
                return Math.abs(fa) < Math.abs(fb) ? a : b;
            }
            
            if (Math.abs(fa) < Math.abs(fb)) {
                [a, b] = [b, a];
                [fa, fb] = [fb, fa];
            }
            
            let c = a;
            let fc = fa;
            let mflag = true;
            let d = b - a;
            
            for (let iter = 0; iter < maxIter; iter++) {
                if (Math.abs(b - a) < tolerance || fb === 0) {
                    return b;
                }
                
                let s;
                if (fa !== fc && fb !== fc) {
                    // Inverse quadratic interpolation
                    s = a * fb * fc / ((fa - fb) * (fa - fc)) +
                        b * fa * fc / ((fb - fa) * (fb - fc)) +
                        c * fa * fb / ((fc - fa) * (fc - fb));
                } else {
                    // Secant method
                    s = b - fb * (b - a) / (fb - fa);
                }
                
                const condition1 = (s < (3 * a + b) / 4 || s > b);
                const condition2 = mflag && (Math.abs(s - b) >= Math.abs(b - c) / 2);
                const condition3 = !mflag && (Math.abs(s - b) >= Math.abs(c - d) / 2);
                const condition4 = mflag && (Math.abs(b - c) < tolerance);
                const condition5 = !mflag && (Math.abs(c - d) < tolerance);

                if (condition1 || condition2 || condition3 || condition4 || condition5) {
                    s = (a + b) / 2;
                    mflag = true;
                } else {
                    mflag = false;
                }
                
                const fs = func(s);
                d = c;
                c = b;
                fc = fb;

                if (fa * fs < 0) {
                    b = s;
                    fb = fs;
                } else {
                    a = s;
                    fa = fs;
                }
                
                if (Math.abs(fa) < Math.abs(fb)) {
                    [a, b] = [b, a];
                    [fa, fb] = [fb, fa];
                }
            }
            return b;
        }
        
        function betaStar(alpha_I, params) {
            const eps = 1e-6;
            
            if (Math.abs(alpha_I - 1.0) < eps) {
                return 1.0;
            }
            
            const f = (ap) => MP_P(ap, alpha_I, params) - MP_I(ap, alpha_I, params);
            
            const f_low = f(eps);
            const f_high = f(1 - eps);
            
            if (f_low * f_high > 0) {
                 // If marginal product of P is always higher, everyone works in P.
                 // If marginal product of I is always higher, everyone works in I.
                return f_low > 0 ? 1.0 : 0.0;
            }
            
            return brentq(f, eps, 1 - eps);
        }
        
        function computeWage(beta_star, alpha_I, params) {
            if (Math.abs(beta_star - 1.0) < 1e-6) return MP_P(1.0, alpha_I, params);
            if (Math.abs(beta_star) < 1e-6) return MP_I(0.0, alpha_I, params);
            // In equilibrium, MP_P = MP_I, so we can use either
            return MP_P(beta_star, alpha_I, params);
        }
        
        function computeTotalOutput(alpha_I, params) {
            const ap = betaStar(alpha_I, params);
            const LP = ap * params.L;
            const LI = (1 - ap) * params.L;
            const P = computeP(LP, params.K, params.alpha_P, params.rho_P, params.theta_P);
            const I = computeI(LI, alpha_I, params.AI, params.rho_I, params.theta_I);
            return computeY(P, I, params);
        }

        // Chart setup
        const wageCtx = document.getElementById('wageChart').getContext('2d');
        const outputCtx = document.getElementById('outputChart').getContext('2d');
        const componentsCtx = document.getElementById('componentsChart').getContext('2d');
        const allocationCtx = document.getElementById('allocationChart').getContext('2d');
        const functionCtx = document.getElementById('functionChart').getContext('2d');
        const physicalCtx = document.getElementById('physicalChart').getContext('2d');
        const intelligenceCtx = document.getElementById('intelligenceChart').getContext('2d');

        const wageChart = new Chart(wageCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Wage',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 5,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                },
                plugins: {
                    title: {
                        display: false
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'α_I (AI share in intelligence production)', font: { size: 11 } },
                        ticks: { font: { size: 10 } }
                    },
                    y: { 
                        title: { display: true, text: 'Wage', font: { size: 11 } },
                        ticks: { font: { size: 10 } },
                        position: 'left'
                    }
                }
            }
        });

        const outputChart = new Chart(outputCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Total Output Y',
                    data: [],
                    borderColor: '#27ae60',
                    backgroundColor: 'rgba(39, 174, 96, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 5,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                },
                plugins: {
                    title: {
                        display: false
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'α_I (AI share in intelligence production)', font: { size: 11 } },
                        ticks: { font: { size: 10 } }
                    },
                    y: { 
                        title: { display: true, text: 'Output Y', font: { size: 11 } },
                        ticks: { font: { size: 10 } },
                        position: 'left'
                    }
                }
            }
        });

        const componentsChart = new Chart(componentsCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'P-nest Output',
                    data: [],
                    borderColor: '#9b59b6',
                    backgroundColor: 'rgba(155, 89, 182, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'I-nest Output',
                    data: [],
                    borderColor: '#f39c12',
                    backgroundColor: 'rgba(243, 156, 18, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 5,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                },
                plugins: {
                    title: {
                        display: false
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'α_I (AI share in intelligence production)', font: { size: 11 } },
                        ticks: { font: { size: 10 } }
                    },
                    y: { 
                        title: { display: true, text: 'Component Output', font: { size: 11 } },
                        ticks: { font: { size: 10 } },
                        position: 'left'
                    }
                }
            }
        });

        const allocationChart = new Chart(allocationCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'β* (Optimal P-labor share)',
                    data: [],
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 5,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                },
                plugins: {
                    title: {
                        display: false
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'α_I (AI share in intelligence production)', font: { size: 11 } },
                        ticks: { font: { size: 10 } }
                    },
                    y: { 
                        title: { display: true, text: 'β* (P-nest labor share)', font: { size: 11 } },
                        ticks: { font: { size: 10 } },
                        position: 'left'
                    }
                }
            }
        });

        const functionChart = new Chart(functionCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'P = Low',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'P = Medium',
                    data: [],
                    borderColor: '#f39c12',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'P = High',
                    data: [],
                    borderColor: '#27ae60',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Y = f(I) for different P values',
                        font: { size: 14 }
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: { title: { display: true, text: 'I (Intelligence Output)' } },
                    y: { title: { display: true, text: 'Y (Total Output)' } }
                }
            }
        });

        const physicalChart = new Chart(physicalCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Kₚ = Low',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'Kₚ = Medium',
                    data: [],
                    borderColor: '#f39c12',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'Kₚ = High',
                    data: [],
                    borderColor: '#27ae60',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 5,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'P = f(Lₚ) for different Kₚ values',
                        font: { size: 13 },
                        padding: { top: 5, bottom: 5 },
                        align: 'start'
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'center',
                        labels: {
                            boxWidth: 15,
                            padding: 8,
                            font: { size: 11 }
                        }
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Lₚ (Physical Labor)', font: { size: 11 } },
                        ticks: { font: { size: 10 } }
                    },
                    y: { 
                        title: { display: true, text: 'P (Physical Output)', font: { size: 11 } },
                        ticks: { font: { size: 10 } },
                        position: 'left'
                    }
                }
            }
        });

        const intelligenceChart = new Chart(intelligenceCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Kᵢ = Low',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'Kᵢ = Medium',
                    data: [],
                    borderColor: '#f39c12',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }, {
                    label: 'Kᵢ = High',
                    data: [],
                    borderColor: '#27ae60',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: {
                        top: 5,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'I = f(Lᵢ) for different Kᵢ values',
                        font: { size: 13 },
                        padding: { top: 5, bottom: 5 },
                        align: 'start'
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'center',
                        labels: {
                            boxWidth: 15,
                            padding: 8,
                            font: { size: 11 }
                        }
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Lᵢ (Intelligence Labor)', font: { size: 11 } },
                        ticks: { font: { size: 10 } }
                    },
                    y: { 
                        title: { display: true, text: 'I (Intelligence Output)', font: { size: 11 } },
                        ticks: { font: { size: 10 } },
                        position: 'left'
                    }
                }
            }
        });

        // Tab functionality
        function switchTab(index) {
            const buttons = document.querySelectorAll('.tab-button');
            const contents = document.querySelectorAll('.tab-content');
            
            buttons.forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
            
            contents.forEach((content, i) => {
                content.classList.toggle('active', i === index);
            });
        }
        
        // Toggle AI mode
        function toggleAIMode() {
            const toggle = document.getElementById('ai_mode_toggle');
            toggle.classList.toggle('active');
            currentAIMode = toggle.classList.contains('active') ? 'Exponential' : 'Fixed';
            updateAIModeVisibility();
            updateCharts();
        }
        
        // Toggle aggregation method
        // Aggregation toggle removed - overall production always uses CES
        
        function togglePAggregation() {
            const toggle = document.getElementById('p_agg_toggle');
            toggle.classList.toggle('active');
            currentPAgg = toggle.classList.contains('active') ? 'DS' : 'CES';
            updateNestParameterVisibility();
            updatePhysicalEquation();
            updatePhysicalChart();
            updateCharts();
        }
        
        // I-aggregation toggle removed - intelligence nest always uses DS
        
        // Update AI mode visibility and text
        function updateAIModeVisibility() {
            const exponentialParams = document.querySelectorAll('.exponential-params');
            const scenarioText = document.getElementById('scenario-text');
            const aiCapitalNote = document.getElementById('ai-capital-note');
            const doublingTime = parseFloat(document.getElementById('doubling_time').value);
            
            if (currentAIMode === 'Fixed') {
                exponentialParams.forEach(param => param.style.display = 'none');
                aiCapitalNote.style.display = 'none';
                scenarioText.textContent = 'We increase the importance of intelligence in overall production.';
            } else {
                exponentialParams.forEach(param => param.style.display = 'block');
                aiCapitalNote.style.display = 'block';
                scenarioText.textContent = ``;
            }
        }
        
        // Update parameter visibility based on aggregation method
        function updateParameterVisibility() {
            // Overall aggregation always uses CES
            const cesParams = document.querySelectorAll('.ces-params');
            const psiParams = document.querySelectorAll('.psi-params');

            cesParams.forEach(param => param.style.display = 'block');
            psiParams.forEach(param => param.style.display = 'none');
        }
        
        function updateNestParameterVisibility() {
            // Physical nest parameters
            const pCesParams = document.querySelectorAll('.p-ces-params');
            const pDsParams = document.querySelectorAll('.p-ds-params');
            
            if (currentPAgg === 'CES') {
                pCesParams.forEach(param => param.style.display = 'block');
                pDsParams.forEach(param => param.style.display = 'none');
            } else {
                pCesParams.forEach(param => param.style.display = 'none');
                pDsParams.forEach(param => param.style.display = 'block');
            }
            
            // Intelligence nest parameters
            const iCesParams = document.querySelectorAll('.i-ces-params');
            const iDsParams = document.querySelectorAll('.i-ds-params');
            
            // Intelligence nest always uses DS (CES with scale)
            iCesParams.forEach(param => param.style.display = 'none');
            iDsParams.forEach(param => param.style.display = 'block');
        }
        
        // Update the physical equation display based on aggregation method
        function updatePhysicalEquation() {
            const equationDiv = document.getElementById('physical-equation');
            if (currentPAgg === 'CES') {
                equationDiv.innerHTML = '$$P = \\left[\\alpha_P K_P^{\\rho_P} + (1-\\alpha_P) L_P^{\\rho_P}\\right]^{1/\\rho_P}$$';
            } else {
                equationDiv.innerHTML = '$$P = \\left[\\alpha_P^{1-\\rho_P} K_P^{\\rho_P} + (1-\\alpha_P)^{1-\\rho_P} L_P^{\\rho_P}\\right]^{\\theta_P/\\rho_P}$$';
            }
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([equationDiv]);
            }
        }
        
        // Update the intelligence equation display based on aggregation method
        function updateIntelligenceEquation() {
            const equationDiv = document.getElementById('intelligence-equation');
            // Intelligence nest always uses DS (CES with scale)
            equationDiv.innerHTML = '$$I = \\left[\\alpha_I^{1-\\rho_I} K_I^{\\rho_I} + (1-\\alpha_I)^{1-\\rho_I} L_I^{\\rho_I}\\right]^{\\theta_I/\\rho_I}$$';
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([equationDiv]);
            }
        }
        
        // Update the equation display based on aggregation method
        function updateEquation() {
            const equationDiv = document.getElementById('overall-equation');
            if (currentAgg === 'CES') {
                equationDiv.innerHTML = '$$Y = \\left[\\tau P^{\\rho} + (1-\\tau) I^{\\rho}\\right]^{1/\\rho}$$';
            } else {
                equationDiv.innerHTML = '$$Y = P \\cdot \\frac{(I/P)^{\\eta}}{a + (I/P)^{\\eta}}$$';
            }
            // Re-render MathJax
            if (window.MathJax) {
                if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([equationDiv]);
            }
            }
        }
        
        // Update the function chart Y = f(I)
        function updateFunctionChart() {
            const params = getParams();
            
            // Calculate meaningful P values based on current parameters
            const alpha_P_typical = 0.5; // Assume balanced allocation
            const LP_typical = alpha_P_typical * params.L;
            const P_typical = computeP(LP_typical, params.K, params.alpha_P, params.rho_P, params.theta_P);
            
            const P_low = P_typical * 0.2;
            const P_medium = P_typical;
            const P_high = P_typical * 5;
            
            // Generate I values
            const I_vals = [];
            const I_max = P_typical * 3; // Reasonable range
            const I_min = 0.1;
            for (let i = 0; i <= 50; i++) {
                I_vals.push(I_min + (I_max - I_min) * i / 50);
            }
            
            // Calculate Y values for each P
            const Y_low = [];
            const Y_medium = [];
            const Y_high = [];
            
            for (const I of I_vals) {
                Y_low.push(computeY(P_low, I, params));
                Y_medium.push(computeY(P_medium, I, params));
                Y_high.push(computeY(P_high, I, params));
            }
            
            const labels = I_vals.map((i, idx) => idx % 2 === 0 ? i.toFixed(2) : '');
            
            // Update chart
            functionChart.data.labels = labels;
            functionChart.data.datasets[0].data = Y_low;
            functionChart.data.datasets[0].label = `P = ${P_low.toFixed(2)}`;
            functionChart.data.datasets[1].data = Y_medium;
            functionChart.data.datasets[1].label = `P = ${P_medium.toFixed(2)}`;
            functionChart.data.datasets[2].data = Y_high;
            functionChart.data.datasets[2].label = `P = ${P_high.toFixed(2)}`;
            functionChart.update('none');
        }
        
        // Update the physical production chart P = f(L_P)
        function updatePhysicalChart() {
            const params = getParams();
            
            // Calculate meaningful K_P values based on current parameter
            const K_P_low = params.K * 0.2;
            const K_P_medium = params.K;
            const K_P_high = params.K * 5;
            
            // Generate L_P values
            const L_P_vals = [];
            const L_P_max = params.L; // Max possible labor allocation
            const L_P_min = 0.01;
            for (let i = 0; i <= 50; i++) {
                L_P_vals.push(L_P_min + (L_P_max - L_P_min) * i / 50);
            }
            
            // Calculate P values for each K_P
            const P_low = [];
            const P_medium = [];
            const P_high = [];
            
            for (const L_P of L_P_vals) {
                P_low.push(computeP(L_P, K_P_low, params.alpha_P, params.rho_P, params.theta_P));
                P_medium.push(computeP(L_P, K_P_medium, params.alpha_P, params.rho_P, params.theta_P));
                P_high.push(computeP(L_P, K_P_high, params.alpha_P, params.rho_P, params.theta_P));
            }
            
            const labels = L_P_vals.map((l, i) => i % 2 === 0 ? l.toFixed(2) : '');
            
            // Update chart
            physicalChart.data.labels = labels;
            physicalChart.data.datasets[0].data = P_low;
            physicalChart.data.datasets[0].label = `Kₚ = ${K_P_low.toFixed(2)}`;
            physicalChart.data.datasets[1].data = P_medium;
            physicalChart.data.datasets[1].label = `Kₚ = ${K_P_medium.toFixed(2)}`;
            physicalChart.data.datasets[2].data = P_high;
            physicalChart.data.datasets[2].label = `Kₚ = ${K_P_high.toFixed(2)}`;
            physicalChart.update('none');
        }
        
        // Update the intelligence production chart I = f(L_I)
        function updateIntelligenceChart() {
            const params = getParams();
            
            // Calculate meaningful K_I values based on current parameter
            const K_I_low = params.AI * 0.2;
            const K_I_medium = params.AI;
            const K_I_high = params.AI * 5;
            
            // Generate L_I values
            const L_I_vals = [];
            const L_I_max = params.L; // Max possible labor allocation
            const L_I_min = 0.01;
            for (let i = 0; i <= 50; i++) {
                L_I_vals.push(L_I_min + (L_I_max - L_I_min) * i / 50);
            }
            
            // Calculate I values for each K_I
            const I_low = [];
            const I_medium = [];
            const I_high = [];
            
            for (const L_I of L_I_vals) {
                I_low.push(computeI(L_I, params.alpha_I, K_I_low, params.rho_I, params.theta_I));
                I_medium.push(computeI(L_I, params.alpha_I, K_I_medium, params.rho_I, params.theta_I));
                I_high.push(computeI(L_I, params.alpha_I, K_I_high, params.rho_I, params.theta_I));
            }
            
            const labels = L_I_vals.map((l, i) => i % 2 === 0 ? l.toFixed(2) : '');
            
            // Update chart
            intelligenceChart.data.labels = labels;
            intelligenceChart.data.datasets[0].data = I_low;
            intelligenceChart.data.datasets[0].label = `Kᵢ = ${K_I_low.toFixed(2)}`;
            intelligenceChart.data.datasets[1].data = I_medium;
            intelligenceChart.data.datasets[1].label = `Kᵢ = ${K_I_medium.toFixed(2)}`;
            intelligenceChart.data.datasets[2].data = I_high;
            intelligenceChart.data.datasets[2].label = `Kᵢ = ${K_I_high.toFixed(2)}`;
            intelligenceChart.update('none');
        }

        // Time evolution functions
        function alpha_I_evolution(t_years, transition_time_years) {
            if (currentAIMode === 'Fixed') {
                return 0.2; // Default alpha_I value for fixed mode
            }
            return Math.min(1.0, Math.max(0.0, t_years / transition_time_years));
        }
        
        function K_I_evolution(t_years, doubling_time_months, initial_K_I) {
            if (currentAIMode === 'Fixed') {
                return initial_K_I;
            }
            const t_months = t_years * 12;
            return initial_K_I * Math.pow(2, t_months / doubling_time_months);
        }
        
        // Parameter management
        function getParams(t_years = null) {
            const base_params = {
                K: parseFloat(document.getElementById('K').value),
                AI: Math.pow(10, parseFloat(document.getElementById('AI').value)),
                L: parseFloat(document.getElementById('L').value),
                alpha_P: parseFloat(document.getElementById('alpha_P').value),
                rho_P: parseFloat(document.getElementById('rho_P').value),
                rho_I: parseFloat(document.getElementById('rho_I').value),
                theta_P: currentPAgg === 'DS' ? parseFloat(document.getElementById('theta_P').value) : 1.0,
                theta_I: parseFloat(document.getElementById('theta_I').value),
                tau: parseFloat(document.getElementById('tau').value),
                rho: parseFloat(document.getElementById('rho').value),
                alpha_I: 0.2, // Default alpha_I value
                agg: currentAgg,
                transition_time: parseFloat(document.getElementById('transition_time').value),
                doubling_time: parseFloat(document.getElementById('doubling_time').value)
            };
            
            if (t_years !== null && currentAIMode === 'Exponential') {
                base_params.alpha_I = alpha_I_evolution(t_years, base_params.transition_time);
                base_params.AI = K_I_evolution(t_years, base_params.doubling_time, base_params.AI);
            }
            
            return base_params;
        }
        
        function updateProductivityChart() {
            let x_vals = [];
            let y_vals = [];
            
            console.log('Computing productivity chart...');
            
            // Generate alpha_I range for productivity calculation
            for (let i = 0; i <= 50; i++) {
                const alpha_I = i / 50.0;
                x_vals.push(alpha_I);
                
                try {
                    // Get parameters with overridden alpha_I
                    const params = getParams();
                    params.alpha_I = alpha_I;
                    
                    // Compute equilibrium output
                    const output = computeTotalOutput(alpha_I, params);
                    
                    if (isFinite(output) && params.K > 0) {
                        const productivity = output / params.K;
                        if (isFinite(productivity)) {
                            y_vals.push(productivity);
                        } else {
                            y_vals.push(null);
                        }
                    } else {
                        y_vals.push(null);
                    }
                } catch (e) {
                    y_vals.push(null);
                }
            }
            
            // Filter out null values
            const validData = x_vals.map((x, i) => ({x, y: y_vals[i]}))
                                   .filter(point => point.y !== null);
            
            // Scale to start at 5% (0.05)
            if (validData.length > 0) {
                const firstValue = validData[0].y;
                const scalingFactor = 0.05 / firstValue;
                
                // Apply scaling to all values
                validData.forEach(point => {
                    point.y = point.y * scalingFactor;
                });
                
                const yValues = validData.map(p => p.y);
                console.log('Productivity data points:', validData.length);
                console.log('MPK range:', (Math.min(...yValues) * 100).toFixed(1) + '%', 'to', (Math.max(...yValues) * 100).toFixed(1) + '%');
            }
            
            if (validData.length === 0) {
                console.error('No valid data points for productivity chart!');
                return;
            }
            
            const existingChart = Chart.getChart('productivityChart');
            if (existingChart) {
                existingChart.destroy();
            }
            
            const ctx = document.getElementById('productivityChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: validData.map(p => p.x.toFixed(3)),
                    datasets: [{
                        label: 'Marginal Product of Capital',
                        data: validData.map(p => p.y * 100), // Convert to percentage
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 2,
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'α_I (AI share in intelligence production)' },
                            ticks: { maxTicksLimit: 6 }
                        },
                        y: {
                            title: { display: true, text: 'Marginal Product of Capital (%)' },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '🌈 Secret Chart: Marginal Product of Capital 🌈',
                            font: { size: 16, weight: 'bold' },
                            color: '#ff6b6b'
                        },
                        legend: { display: true }
                    }
                }
            });
        }




        function updateCharts() {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = 'Computing equilibrium...';
            statusDiv.className = 'status';
            
            setTimeout(() => {
                try {
                    const base_params = getParams();
                    
                    let x_vals = [];
                    let x_labels = [];
                    let x_title = '';
                    
                    if (currentAIMode === 'Fixed') {
                        const N = 50;
                        for (let i = 0; i <= N; i++) {
                          const a = i / N;                  // for labels
                          const aEval =
                            i === 0    ? ALPHA_EPS :        // 0⁺
                            i === N    ? 1 - ALPHA_EPS :    // 1⁻
                                         a;                 // interior
                          x_vals.push(aEval);
                        }
                        // keep axis labels pretty (show 0 and 1 even though we eval at 0⁺/1⁻)
                        x_labels = Array.from({length: 51}, (_, i) => (i/50).toFixed(3));
                        x_title = 'α_I (AI share in intelligence production)';
                    } else {
                        // Generate time grid
                        const max_time = base_params.transition_time + 5; // Show 5 years past when alpha_I reaches 1
                        for (let i = 0; i <= 50; i++) {
                            x_vals.push(max_time * i / 50.0);
                        }
                        x_labels = x_vals.map(t => t.toFixed(1));
                        x_title = 'Time (years)';
                    }
                    
                    const wages = [];
                    const outputs = [];
                    const allocations = [];
                    const pOutputs = [];
                    const iOutputs = [];
                    const saturationVals = [];
                    let successCount = 0;
                    
                    for (const x_val of x_vals) {
                        try {
                            let params;
                            if (currentAIMode === 'Fixed') {
                                // x_val is alpha_I
                                params = getParams();
                                params.alpha_I = x_val; // Override alpha_I for this iteration
                            } else {
                                // x_val is time in years
                                params = getParams(x_val); // Get time-evolved parameters
                            }
                            
                            const beta_star = betaStar(params.alpha_I, params);
                            const wage = computeWage(beta_star, params.alpha_I, params);
                            const output = computeTotalOutput(params.alpha_I, params);
                            
                            // Calculate P and I components
                            const LP = beta_star * params.L;
                            const LI = (1 - beta_star) * params.L;
                            const P = computeP(LP, params.K, params.alpha_P, params.rho_P, params.theta_P);
                            const I = computeI(LI, params.alpha_I, params.AI, params.rho_I, params.theta_I);
                            
                            // Calculate saturation ratio
                            let saturation = null;
                            if (params.alpha_I >= 1e-6) {
                                try {
                                    // Calculate Y_current (already calculated as 'output')
                                    const Y_current = output;
                                    
                                    // Calculate I with K_I → ∞ AND β_I → ∞ (keep same P, same labor allocation)
                                    const I_infinite = computeI(LI, 1.0, 1e50, params.rho_I, params.theta_I);
                                    
                                    // Calculate Y_infinite
                                    // Always use CES for overall aggregation
                                    const Y_infinite = Math.pow(params.tau * Math.pow(P, params.rho) + (1 - params.tau) * Math.pow(I_infinite, params.rho), 1 / params.rho);
                                    
                                    const saturationRatio = Y_current / Y_infinite;
                                    if (isFinite(saturationRatio) && saturationRatio >= 0 && saturationRatio <= 1) {
                                        saturation = saturationRatio * 100; // Convert to percentage
                                    }
                                } catch (e) {
                                    // Keep saturation as null
                                }
                            }
                            
                            if (isFinite(wage) && isFinite(output) && isFinite(beta_star) && isFinite(P) && isFinite(I)) {
                                wages.push(wage);
                                outputs.push(output);
                                allocations.push(beta_star);
                                pOutputs.push(P);
                                iOutputs.push(I);
                                saturationVals.push(saturation);
                                successCount++;
                            } else {
                                wages.push(null);
                                outputs.push(null);
                                allocations.push(null);
                                pOutputs.push(null);
                                iOutputs.push(null);
                                saturationVals.push(null);
                            }
                        } catch (error) {
                            wages.push(null);
                            outputs.push(null);
                            allocations.push(null);
                            pOutputs.push(null);
                            iOutputs.push(null);
                            saturationVals.push(null);
                        }
                    }
                    
                    // Update charts
                    wageChart.data.labels = x_labels;
                    wageChart.data.datasets[0].data = wages;
                    wageChart.options.scales.x.title.text = x_title;
                    wageChart.options.scales.x.ticks = { maxTicksLimit: 6 };
                    
                    // Add/remove vertical line based on mode
                    if (currentAIMode === 'Exponential') {
                        const transitionTime = base_params.transition_time;
                        const max_time = base_params.transition_time + 5;
                        // Find the index where transition occurs
                        const transitionIndex = Math.round((transitionTime / max_time) * 50);
                        wageChart.options.plugins.annotation = {
                            annotations: {
                                transitionLine: {
                                    type: 'line',
                                    xMin: transitionIndex,
                                    xMax: transitionIndex,
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: 'α_I = 1 (full automation)',
                                        enabled: true,
                                        position: 'top'
                                    }
                                }
                            }
                        };
                        outputChart.options.plugins.annotation = {
                            annotations: {
                                transitionLine: {
                                    type: 'line',
                                    xMin: transitionIndex,
                                    xMax: transitionIndex,
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: 'α_I = 1 (full automation)',
                                        enabled: true,
                                        position: 'top'
                                    }
                                }
                            }
                        };
                        componentsChart.options.plugins.annotation = {
                            annotations: {
                                transitionLine: {
                                    type: 'line',
                                    xMin: transitionIndex,
                                    xMax: transitionIndex,
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: 'α_I = 1 (full automation)',
                                        enabled: true,
                                        position: 'top'
                                    }
                                }
                            }
                        };
                        allocationChart.options.plugins.annotation = {
                            annotations: {
                                transitionLine: {
                                    type: 'line',
                                    xMin: transitionIndex,
                                    xMax: transitionIndex,
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: 'α_I = 1 (full automation)',
                                        enabled: true,
                                        position: 'top'
                                    }
                                }
                            }
                        };
                    } else {
                        // Remove annotation for Fixed mode
                        delete wageChart.options.plugins.annotation;
                        delete outputChart.options.plugins.annotation;
                        delete componentsChart.options.plugins.annotation;
                        delete allocationChart.options.plugins.annotation;
                    }
                    
                    wageChart.update('none');

                    outputChart.data.labels = x_labels;
                    outputChart.data.datasets[0].data = outputs;
                    outputChart.options.scales.x.title.text = x_title;
                    outputChart.options.scales.x.ticks = { maxTicksLimit: 6 };
                    outputChart.update('none');

                    componentsChart.data.labels = x_labels;
                    componentsChart.data.datasets[0].data = pOutputs;
                    componentsChart.data.datasets[1].data = iOutputs;
                    componentsChart.options.scales.x.title.text = x_title;
                    componentsChart.options.scales.x.ticks = { maxTicksLimit: 6 };
                    componentsChart.update('none');

                    allocationChart.data.labels = x_labels;
                    allocationChart.data.datasets[0].data = allocations;
                    allocationChart.options.scales.x.title.text = x_title;
                    allocationChart.options.scales.x.ticks = { maxTicksLimit: 6 };
                    allocationChart.update('none');

                    // Update saturation chart
                    const validSaturationData = x_vals.map((x, i) => ({x, y: saturationVals[i]}))
                                                      .filter(point => point.y !== null);
                    
                    const existingSaturationChart = Chart.getChart('saturationChart');
                    if (existingSaturationChart) {
                        existingSaturationChart.destroy();
                    }
                    
                    if (validSaturationData.length > 0) {
                        const saturationCtx = document.getElementById('saturationChart').getContext('2d');
                        new Chart(saturationCtx, {
                            type: 'line',
                            data: {
                                labels: validSaturationData.map(p => p.x.toFixed(3)),
                                datasets: [{
                                    label: 'Intelligence Saturation',
                                    data: validSaturationData.map(p => p.y),
                                    borderColor: '#9b59b6',
                                    backgroundColor: 'rgba(155, 89, 182, 0.1)',
                                    fill: true,
                                    tension: 0.4,
                                    pointRadius: 2,
                                    borderWidth: 3
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        title: { display: true, text: x_title },
                                        ticks: { maxTicksLimit: 6 }
                                    },
                                    y: {
                                        title: { display: true, text: 'Intelligence Saturation (%)' },
                                        min: 0,
                                        max: 100,
                                        ticks: {
                                            callback: function(value) {
                                                return value.toFixed(0) + '%';
                                            }
                                        }
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: false
                                    },
                                    legend: { display: false }
                                }
                            }
                        });
                    }
                    
                    // Clear status message
                    statusDiv.textContent = '';
                    statusDiv.className = 'status';
                    
                } catch (error) {
                    console.error('Simulation error:', error);
                    statusDiv.textContent = 'Error: ' + error.message;
                    statusDiv.className = 'status error';
                }
            }, 100);
        }

        // Event listeners for sliders
        function setupSliders() {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                const valueSpan = document.getElementById(slider.id + '_value');
                
                slider.addEventListener('input', function() {
                    if (this.id === 'AI') {
                        // Log scale display: show 10^value
                        const x = Math.pow(10, parseFloat(this.value));
                        valueSpan.textContent = (x >= 0.001 && x < 10000) ? x.toFixed(1) : x.toExponential(2);
                    } else {
                        valueSpan.textContent = this.value;
                    }

                    // Update elasticity displays for rho parameters
                    if (this.id === 'rho_P') {
                        const sigma = 1 / (1 - parseFloat(this.value));
                        document.getElementById('sigma_P_display').textContent = `σ = ${sigma.toFixed(1)}`;
                    } else if (this.id === 'rho_I') {
                        const sigma = 1 / (1 - parseFloat(this.value));
                        document.getElementById('sigma_I_display').textContent = `σ = ${sigma.toFixed(1)}`;
                    } else if (this.id === 'rho') {
                        const sigma = 1 / (1 - parseFloat(this.value));
                        document.getElementById('sigma_display').textContent = `σ = ${sigma.toFixed(1)}`;
                    }
                });
                
                slider.addEventListener('input', function() {
                    updatePhysicalChart();
                    updateIntelligenceChart();
                    updateFunctionChart();
                    if (this.id === 'doubling_time') {
                        updateAIModeVisibility();
                    }
                    updateCharts();
                });
            });
        }

        // Reset all parameters to defaults
        function resetAllParameters() {
            // Physical tab
            document.getElementById('K').value = '1.38';
            document.getElementById('K_value').textContent = '1.38';
            document.getElementById('alpha_P').value = '0.7';
            document.getElementById('alpha_P_value').textContent = '0.7';
            document.getElementById('rho_P').value = '-0.67';
            document.getElementById('rho_P_value').textContent = '-0.67';
            document.getElementById('theta_P').value = '1.0';
            document.getElementById('theta_P_value').textContent = '1.0';
            
            // Intelligence tab
            document.getElementById('AI').value = '0.95';
            document.getElementById('AI_value').textContent = '9.0';
            document.getElementById('rho_I').value = '0.55';
            document.getElementById('rho_I_value').textContent = '0.55';
            document.getElementById('theta_I').value = '0.94';
            document.getElementById('theta_I_value').textContent = '0.94';
            
            // Overall tab
            document.getElementById('L').value = '1.0';
            document.getElementById('L_value').textContent = '1.0';
            document.getElementById('tau').value = '0.20';
            document.getElementById('tau_value').textContent = '0.20';
            document.getElementById('rho').value = '-0.67';
            document.getElementById('rho_value').textContent = '-0.67';
            document.getElementById('eta').value = '0.5';
            document.getElementById('eta_value').textContent = '0.5';
            document.getElementById('a_param').value = '4.6';
            document.getElementById('a_param_value').textContent = '4.6';
            
            // Analysis tab
            document.getElementById('transition_time').value = '10';
            document.getElementById('transition_time_value').textContent = '10';
            document.getElementById('doubling_time').value = '3';
            document.getElementById('doubling_time_value').textContent = '3';
            
            // Reset toggles to defaults
            currentPAgg = 'CES';
            currentIAgg = 'DS';
            currentAgg = 'CES';
            currentAIMode = 'Fixed';
            
            // Update toggle visual states
            document.getElementById('p_agg_toggle').classList.remove('active');
            // i_agg_toggle removed - intelligence nest always uses DS
            // agg_toggle removed - overall aggregation always uses CES
            document.getElementById('ai_mode_toggle').classList.remove('active');
            
            // Update visibility and charts
            updateParameterVisibility();
            updateNestParameterVisibility();
            updatePhysicalEquation();
            updateIntelligenceEquation();
            updateAIModeVisibility();
            // Update elasticity displays
            document.getElementById('sigma_P_display').textContent = 'σ = 0.6';
            document.getElementById('sigma_I_display').textContent = 'σ = 2.2';
            document.getElementById('sigma_display').textContent = 'σ = 0.6';

            updatePhysicalChart();
            updateIntelligenceChart();
            updateFunctionChart();
            updateCharts();
        }
        
        // Toggle explanations visibility
        function toggleExplanations() {
            const descriptions = document.querySelectorAll('.parameter-description');
            const labels = document.querySelectorAll('.parameter-label');
            const toggleButton = document.getElementById('explanationsToggle');
            
            const isCurrentlyHidden = toggleButton.classList.contains('explanations-off');
            
            if (isCurrentlyHidden) {
                // Show explanations
                descriptions.forEach(desc => desc.classList.remove('minimized'));
                labels.forEach(label => {
                    label.classList.remove('has-tooltip');
                    label.removeAttribute('data-tooltip');
                });
                toggleButton.textContent = 'Toggle tool tips';
                toggleButton.classList.remove('explanations-off');
            } else {
                // Hide explanations and add tooltips
                descriptions.forEach(desc => {
                    desc.classList.add('minimized');
                    const label = desc.previousElementSibling;
                    if (label && label.classList.contains('parameter-label')) {
                        label.classList.add('has-tooltip');
                        label.setAttribute('data-tooltip', desc.textContent);
                    }
                });
                toggleButton.textContent = 'Toggle tool tips';
                toggleButton.classList.add('explanations-off');
            }
        }
        
        // Export functions
        function exportChart(chartId, filename) {
            const chart = Chart.getChart(chartId);
            if (!chart) return;
            
            // Create a temporary canvas with white background
            const canvas = document.createElement('canvas');
            canvas.width = chart.canvas.width;
            canvas.height = chart.canvas.height;
            const ctx = canvas.getContext('2d');
            
            // Fill white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the chart
            ctx.drawImage(chart.canvas, 0, 0);
            
            // Convert to SVG using canvas2svg (we'll use PNG for now)
            // For true SVG export, you'd need a library like canvas2svg
            // For now, we'll download as high-quality PNG
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename + '.png';
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }
        
        function exportChartPNG(chartId, filename) {
            const chart = Chart.getChart(chartId);
            if (!chart) return;
            
            // Create a temporary canvas with white background
            const canvas = document.createElement('canvas');
            canvas.width = chart.canvas.width;
            canvas.height = chart.canvas.height;
            const ctx = canvas.getContext('2d');
            
            // Fill white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the chart
            ctx.drawImage(chart.canvas, 0, 0);
            
            // Download as PNG
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename + '.png';
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }
        
        function exportChartCSV(chartId, filename) {
            const chart = Chart.getChart(chartId);
            if (!chart) return;
            
            let csv = '';
            const datasets = chart.data.datasets;
            const labels = chart.data.labels;
            
            // Create header row
            csv += 'X-Axis';
            datasets.forEach(dataset => {
                csv += ',' + dataset.label.replace(/,/g, ';'); // Replace commas in labels
            });
            csv += '\n';
            
            // Add data rows
            labels.forEach((label, index) => {
                csv += (label || index); // Use index if label is empty
                datasets.forEach(dataset => {
                    const value = dataset.data[index];
                    csv += ',' + (value !== null && value !== undefined ? value : '');
                });
                csv += '\n';
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Secret toggle functionality
        let secretSequence = [];
        let secretCode = ['k', 'o', 'n', 'r', 'a', 'd'];
        let secretMode = false;

        function handleSecretKeypress(event) {
            // Don't capture if user is typing in an input field
            if (event.target.tagName === 'INPUT') return;
            
            secretSequence.push(event.key.toLowerCase());
            
            // Keep only the last N characters where N is the secret code length
            if (secretSequence.length > secretCode.length) {
                secretSequence = secretSequence.slice(-secretCode.length);
            }
            
            // Check if sequence matches
            if (secretSequence.length === secretCode.length && 
                secretSequence.every((key, index) => key === secretCode[index])) {
                toggleSecretMode();
                secretSequence = []; // Reset sequence
            }
        }

        function toggleSecretMode() {
            secretMode = !secretMode;
            const body = document.body;
            const secretChart = document.getElementById('secretChart');
            
            if (secretMode) {
                body.style.background = 'linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd)';
                body.style.backgroundSize = '400% 400%';
                body.style.animation = 'rainbow 3s ease infinite';
                
                // Show secret chart
                secretChart.style.display = 'block';
                
                // Add rainbow animation keyframes if not already present
                if (!document.getElementById('rainbow-style')) {
                    const style = document.createElement('style');
                    style.id = 'rainbow-style';
                    style.textContent = `
                        @keyframes rainbow {
                            0% { background-position: 0% 50%; }
                            50% { background-position: 100% 50%; }
                            100% { background-position: 0% 50%; }
                        }
                        .secret-sparkle {
                            position: fixed;
                            pointer-events: none;
                            font-size: 20px;
                            animation: sparkle 2s linear infinite;
                            z-index: 9999;
                        }
                        @keyframes sparkle {
                            0% { opacity: 1; transform: translateY(0px) rotate(0deg); }
                            100% { opacity: 0; transform: translateY(-100px) rotate(360deg); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Create sparkle effect and update chart
                createSparkles();
                updateProductivityChart();
                console.log('🌈 Secret rainbow mode activated! Y/K_P chart revealed! 🌈');
            } else {
                body.style.background = '';
                body.style.backgroundSize = '';
                body.style.animation = '';
                secretChart.style.display = 'none';
                console.log('Secret mode deactivated');
            }
        }

        function createSparkles() {
            const sparkleEmojis = ['✨', '⭐', '🌟', '💫', '🔥', '🎉', '🎊'];
            
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'secret-sparkle';
                    sparkle.textContent = sparkleEmojis[Math.floor(Math.random() * sparkleEmojis.length)];
                    sparkle.style.left = Math.random() * window.innerWidth + 'px';
                    sparkle.style.top = Math.random() * window.innerHeight + 'px';
                    document.body.appendChild(sparkle);
                    
                    setTimeout(() => {
                        if (sparkle.parentNode) {
                            sparkle.parentNode.removeChild(sparkle);
                        }
                    }, 2000);
                }, i * 200);
            }
        }

        // Add secret keypress listener
        document.addEventListener('keydown', handleSecretKeypress);

        // Initialize
        // Initialize the first tab as active
        switchTab(0);
        setupSliders();
        updateParameterVisibility();
        updateNestParameterVisibility();
        updatePhysicalEquation();
        updateIntelligenceEquation();
        updateAIModeVisibility();
        updatePhysicalChart();
        updateIntelligenceChart();
        updateFunctionChart();
        updateCharts();
    </script>
</body>
</html>
