<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Two‑Sector AI‑Economy Simulator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js for plotting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chart.js/4.4.2/chart.umd.min.js"></script>
  <!-- numeric.js for optimisation / root‑finding -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <style>
    body{font-family:system-ui,Arial,sans-serif;margin:20px;line-height:1.4;background:#f8f9fa;color:#333}
    h1{font-size:1.6rem;margin-bottom:1rem}
    h2{font-size:1.2rem;margin:26px 0 8px}
    .controls{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px;margin-bottom:20px}
    .param label{display:flex;justify-content:space-between;font-weight:600;margin-bottom:2px}
    .param input[type=range]{width:100%}
    button{background:#0066ff;color:#fff;border:none;padding:8px 16px;font-size:1rem;border-radius:6px;cursor:pointer}
    button:hover{background:#0044cc}
    canvas{max-width:100%;height:280px}
  </style>
</head>
<body>
  <h1>Two‑Sector AI Economy Simulator</h1>
  <p>Adjust any primitive below (all <em>except</em> the computational‑sector share β<sub>C</sub>). Then click <strong>Run Simulation</strong>. The page solves for equilibrium wage <em>w</em> and total output <em>Y</em> over β<sub>C</sub> ∈ [0.05, 0.95] and draws the curves.</p>

  <div class="controls" id="controls">
    <div class="param"><label>σ<sub>Y</sub>: <span id="sigmaYVal">1</span></label><input type="range" id="sigmaY" min="0.5" max="2" step="0.05" value="1" oninput="sigmaYVal.textContent=this.value"/></div>
    <div class="param"><label>α<sub>p</sub>: <span id="alphaPVal">0.4</span></label><input type="range" id="alphaP" min="0" max="1" step="0.05" value="0.4" oninput="alphaPVal.textContent=this.value"/></div>
    <div class="param"><label>α<sub>i</sub>: <span id="alphaIVal">0.6</span></label><input type="range" id="alphaI" min="0" max="1" step="0.05" value="0.6" oninput="alphaIVal.textContent=this.value"/></div>
    <div class="param"><label>ρ<sub>p</sub>: <span id="rhoPVal">-0.5</span></label><input type="range" id="rhoP" min="-0.9" max="0" step="0.05" value="-0.5" oninput="rhoPVal.textContent=this.value"/></div>
    <div class="param"><label>ρ<sub>i</sub>: <span id="rhoIVal">0.5</span></label><input type="range" id="rhoI" min="0" max="0.9" step="0.05" value="0.5" oninput="rhoIVal.textContent=this.value"/></div>
    <div class="param"><label>K<sub>Bp</sub>: <span id="K_BpVal">1</span></label><input type="range" id="K_Bp" min="0.2" max="3" step="0.1" value="1" oninput="K_BpVal.textContent=this.value"/></div>
    <div class="param"><label>K<sub>Cp</sub>: <span id="K_CpVal">1</span></label><input type="range" id="K_Cp" min="0.2" max="3" step="0.1" value="1" oninput="K_CpVal.textContent=this.value"/></div>
    <div class="param"><label>K<sub>Bi</sub>: <span id="K_BiVal">0.001</span></label><input type="range" id="K_Bi" min="0" max="0.1" step="0.001" value="0.001" oninput="K_BiVal.textContent=this.value"/></div>
    <div class="param"><label>K<sub>Ci</sub>: <span id="K_CiVal">1</span></label><input type="range" id="K_Ci" min="0.1" max="5" step="0.1" value="1" oninput="K_CiVal.textContent=this.value"/></div>
    <div class="param"><label>η: <span id="etaVal">1</span></label><input type="range" id="eta" min="0.1" max="3" step="0.1" value="1" oninput="etaVal.textContent=this.value"/></div>
    <div class="param"><label>a<sub>σ</sub>: <span id="aSigmaVal">1</span></label><input type="range" id="aSigma" min="0.1" max="5" step="0.1" value="1" oninput="aSigmaVal.textContent=this.value"/></div>
    <div class="param"><label>L<sub>tot</sub>: <span id="L_totVal">1</span></label><input type="range" id="L_tot" min="0.5" max="5" step="0.1" value="1" oninput="L_totVal.textContent=this.value"/></div>
  </div>

  <button id="runBtn">Run Simulation</button>

  <h2>Equilibrium Wage</h2>
  <canvas id="wageChart"></canvas>

  <h2>Total Output</h2>
  <canvas id="outputChart"></canvas>

  <script>
    /* ---------------- Helper math ---------------- */
    const sigmaFun = (r, eta, a) => Math.pow(r, eta) / (a + Math.pow(r, eta));
    const sigmaPrime = (r, eta, a) => (eta * a * Math.pow(r, eta - 1)) / Math.pow(a + Math.pow(r, eta), 2);

    /* Collect slider positions as a parameter object */
    function getParams(){
      return {
        sigma_Y: parseFloat(sigmaY.value),
        alpha_p: parseFloat(alphaP.value),
        alpha_i: parseFloat(alphaI.value),
        rho_p:  parseFloat(rhoP.value),
        rho_i:  parseFloat(rhoI.value),
        K_Bp:   parseFloat(K_Bp.value),
        K_Cp:   parseFloat(K_Cp.value),
        K_Bi:   parseFloat(K_Bi.value),
        K_Ci:   parseFloat(K_Ci.value),
        eta:    parseFloat(eta.value),
        a_sigma:parseFloat(aSigma.value),
        L_tot:  parseFloat(L_tot.value)
      };
    }

    /* Core equilibrium solver (numeric.uncmin) */
    function solveEquilibrium(betaC, p){
      const q = (p.sigma_Y - 1) / p.sigma_Y;
      const eq = v => {
        const [logw, logLBp, logLBi, logLCp, logLCi] = v;
        const w = Math.exp(logw);
        const LBp = Math.exp(logLBp), LBi = Math.exp(logLBi),
              LCp = Math.exp(logLCp), LCi = Math.exp(logLCi);

        const PB = Math.pow(p.alpha_p*Math.pow(p.K_Bp,p.rho_p)+(1-p.alpha_p)*Math.pow(LBp,p.rho_p),1/p.rho_p);
        const IB = Math.pow(p.alpha_i*Math.pow(p.K_Bi,p.rho_i)+(1-p.alpha_i)*Math.pow(LBi,p.rho_i),1/p.rho_i);
        const rB = IB/PB;
        const yB = PB * sigmaFun(rB,p.eta,p.a_sigma);

        const PC = Math.pow(p.alpha_p*Math.pow(p.K_Cp,p.rho_p)+(1-p.alpha_p)*Math.pow(LCp,p.rho_p),1/p.rho_p);
        const IC = Math.pow(p.alpha_i*Math.pow(p.K_Ci,p.rho_i)+(1-p.alpha_i)*Math.pow(LCi,p.rho_i),1/p.rho_i);
        const rC = IC/PC;
        const yC = PC * sigmaFun(rC,p.eta,p.a_sigma);

        const Y = Math.abs(p.sigma_Y-1)<1e-8 ? Math.pow(yB,1-betaC)*Math.pow(yC,betaC)
                  : Math.pow((1-betaC)*Math.pow(yB,q)+betaC*Math.pow(yC,q),1/q);

        const pB = (1-betaC)*Math.pow(yB/Y,-1/p.sigma_Y);
        const pC = betaC     *Math.pow(yC/Y,-1/p.sigma_Y);

        const sigB  = sigmaFun(rB,p.eta,p.a_sigma);
        const sigpB = sigmaPrime(rB,p.eta,p.a_sigma);
        const sigC  = sigmaFun(rC,p.eta,p.a_sigma);
        const sigpC = sigmaPrime(rC,p.eta,p.a_sigma);

        const MPL_Bp = pB*(sigB-rB*sigpB)*(1-p.alpha_p)*Math.pow(LBp,p.rho_p-1)*Math.pow(PB,1-p.rho_p);
        const MPL_Bi = pB*sigpB            * (1-p.alpha_i)*Math.pow(LBi,p.rho_i-1)*Math.pow(IB,1-p.rho_i);
        const MPL_Cp = pC*(sigC-rC*sigpC)*(1-p.alpha_p)*Math.pow(LCp,p.rho_p-1)*Math.pow(PC,1-p.rho_p);
        const MPL_Ci = pC*sigpC            * (1-p.alpha_i)*Math.pow(LCi,p.rho_i-1)*Math.pow(IC,1-p.rho_i);

        return [
          Math.log(MPL_Bp)-Math.log(w),
          Math.log(MPL_Bi)-Math.log(w),
          Math.log(MPL_Cp)-Math.log(w),
          Math.log(MPL_Ci)-Math.log(w),
          LBp+LBi+LCp+LCi-p.L_tot
        ];
      };

      /* minimise squared residuals */
      const x0=[Math.log(0.1),Math.log(p.L_tot/4),Math.log(p.L_tot/4),Math.log(p.L_tot/4),Math.log(p.L_tot/4)];
      const sol=numeric.uncmin(v=>{const e=eq(v);return e.reduce((s,x)=>s+x*x,0)},x0,1e-10);
      const residual=eq(sol.solution).reduce((s,x)=>s+Math.abs(x),0);
      if(residual>1e-6||!isFinite(sol.solution[0]))return null; // no convergence

      // extract wage & recompute Y
      const [logw,logLBp,logLBi,logLCp,logLCi]=sol.solution;
      const w=Math.exp(logw);
      const LBp=Math.exp(logLBp),LBi=Math.exp(logLBi),LCp=Math.exp(logLCp),LCi=Math.exp(logLCi);

      const PB=Math.pow(p.alpha_p*Math.pow(p.K_Bp,p.rho_p)+(1-p.alpha_p)*Math.pow(LBp,p.rho_p),1/p.rho_p);
      const IB=Math.pow(p.alpha_i*Math.pow(p.K_Bi,p.rho_i)+(1-p.alpha_i)*Math.pow(LBi,p.rho_i),1/p.rho_i);
      const yB=PB*sigmaFun(IB/PB,p.eta,p.a_sigma);
      const PC=Math.pow(p.alpha_p*Math.pow(p.K_Cp,p.rho_p)+(1-p.alpha_p)*Math.pow(LCp,p.rho_p),1/p.rho_p);
      const IC=Math.pow(p.alpha_i*Math.pow(p.K_Ci,p.rho_i)+(1-p.alpha_i)*Math.pow(LCi,p.rho_i),1/p.rho_i);
      const yC=PC*sigmaFun(IC/PC,p.eta,p.a_sigma);
      const Y=Math.abs(p.sigma_Y-1)<1e-8?Math.pow(yB,1-betaC)*Math.pow(yC,betaC):Math.pow((1-betaC)*Math.pow(yB,q)+betaC*Math.pow(yC,q),1/q);

      return {w,Y};
    }

    /* Iterate over β_C grid and collect results */
    function runSimulation(){
      const p=getParams();
      const betas=[],wages=[],outputs=[];
      for(let beta=0.05;beta<=0.95;beta+=0.05){
        const res=solveEquilibrium(beta,p);
        if(res){betas.push(beta.toFixed(2));wages.push(res.w);outputs.push(res.Y);} // skip non‑convergent points
      }
      updateCharts(betas,wages,outputs);
    }

    /* Chart.js refresher */
    let wageChart,outputChart;
    function updateCharts(xs,ws,Ys){
      if(!wageChart){
        wageChart=new Chart(document.getElementById('wageChart'),{
          type:'line',data:{labels:xs,datasets:[{label:'Wage',data:ws,fill:false,tension:0.1}]},
          options:{scales:{x:{title:{display:true,text:'β_C'}},y:{title:{display:true,text:'w'}}}}
        });
      }else{
        wageChart.data.labels=xs;wageChart.data.datasets[0].data=ws;wageChart.update();
      }
      if(!outputChart){
        outputChart=new Chart(document.getElementById('outputChart'),{
          type:'line',data:{labels:xs,datasets:[{label:'Aggregate Output Y',data: Ys,fill:false,tension:0.1}]},
          options:{scales:{x:{title:{display:true,text:'β_C'}},y:{title:{display:true,text:'Y'}}}}
        });
      }else{
        outputChart.data.labels=xs;outputChart.data.datasets[0].data=Ys;outputChart.update();
      }
    }

    document.getElementById('runBtn').addEventListener('click',runSimulation);
    window.addEventListener('load',()=>setTimeout(runSimulation,100));
  </script>
</body>
</html>
